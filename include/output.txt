===== Bishop.h =====
#pragma once
#include "Piece.h"

class Bishop : virtual public Piece
{
protected:
    std::array<int, 4> possible_moves = {-9, -7, 7, 9};
};


===== Black.h =====
#pragma once
#include "Piece.h"
#include "White.h"

class Black : virtual public Piece
{
protected:
    const bool isWhite = false;

public:
    static U64 squares_controlled;
};


===== BlackBishop.h =====
#pragma once
#include "Bishop.h"

class BlackBishop : public Bishop
{
public:
    void CalculateBlackBishopsPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;
            for (auto each : possible_moves)
            {
                int to_square = i + each;
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;

                    while (std::abs(from_rank - to_rank) == 1 && std::abs(from_file - to_file) == 1 && to_square >= 0 && to_square < 64)
                    {
                        pre_attacks_coordinates.at(i).push_back(to_square);
                        to_square += each;
                    }
                }
            }
        }
    }

    std::vector<std::pair<int, int>> CalculateBlackBishopsMoves()
    {
        moves_vector.clear();

        for (int from_square : linear_coordinates)
        {
            const auto &attacks = pre_attacks_coordinates.at(from_square);
            for (size_t i = 0; i < attacks.size(); ++i)
            {
                int to_square = attacks[i];
                U64 target_mask = 1ULL << to_square;

                if (!(target_mask & all_pieces_mask))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                }
                else if (target_mask & white_pieces_mask)
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));

                    int current_direction = to_square - from_square;

                    while (i + 1 < attacks.size() &&
                           (attacks[i + 1] - from_square) / std::abs(attacks[i + 1] - from_square) ==
                               current_direction / std::abs(current_direction))
                    {
                        ++i;
                    }
                }
                else
                {
                    int current_direction = to_square - from_square;

                    while (i + 1 < attacks.size() &&
                           (attacks[i + 1] - from_square) / std::abs(attacks[i + 1] - from_square) ==
                               current_direction / std::abs(current_direction))
                    {
                        ++i;
                    }
                }
            }
        }
        return moves_vector;
    }

    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 from_square_bishop_mask, std::vector<int> &linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        from_square_bishop_mask ^= from_mask;
        from_square_bishop_mask ^= to_mask;
        if (to_mask & white_pieces_mask)
        {
            MaskToCapture(to_mask, true);
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }

        return from_square_bishop_mask;
    }
};


===== BlackKing.h =====
#pragma once
#include "King.h"
#include "Black.h"

class BlackKing : public King, public Black
{
public:
    void CalculateBlackKingPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;

            for (int j = 0; j < 8; ++j)
            {
                int to_square = i + possible_moves[j];
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;
                    int diff_rank = abs(from_rank - to_rank);
                    int diff_file = abs(from_file - to_file);
                    if ((diff_file == 1 && diff_rank == 1) || (diff_file == 1 && diff_rank == 0) || (diff_file == 0 && diff_rank == 1))
                    {
                        pre_attacks_coordinates[i].push_back(to_square);
                    }
                }
            }
        }
    }
    std::vector<std::pair<int, int>> CalculateBlackKingMoves()
    {
        moves_vector.clear();
        
        for (int from_square : linear_coordinates)
        {
            for (int to_square : pre_attacks_coordinates[from_square])
            {
                U64 target_mask = 1ULL << to_square;
                if(!(target_mask & black_bitboard) && !(target_mask & White::squares_controlled))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;
                }
            }
        }
        return moves_vector;
    }
    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 from_square_king_mask, std::vector<int>& linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        from_square_king_mask ^= from_mask;
        from_square_king_mask ^= to_mask;
        if (to_mask & white_bitboard)
        {
            MaskToCapture(to_mask, false);
        }

        for(int i = 0; i < linear_coordinates.size(); ++i)
        {
            if(linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }
        return from_square_king_mask;
    }
};


===== BlackKnight.h =====
#pragma once
#include "Knight.h"

class BlackKnight : public Knight
{
public:
    void CalculateBlackKnightsPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;

            for (int j = 0; j < 8; ++j)
            {
                int to_square = i + possible_moves[j];
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;
                    int diff_rank = abs(from_rank - to_rank);
                    int diff_file = abs(from_file - to_file);
                    if (diff_file + diff_rank == 3 && diff_file > 0 && diff_rank > 0)
                    {
                        pre_attacks_coordinates[i].push_back(to_square);
                    }
                }
            }
        }
    }

    std::vector<std::pair<int, int>> CalculateBlackKnightsMoves()
    {
        moves_vector.clear();

        for (int from_square : linear_coordinates)
        {
            for (int to_square : pre_attacks_coordinates[from_square])
            {
                U64 target_mask = 1ULL << to_square;
                if (!(target_mask & black_pieces_mask))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                }
            }
        }
        return moves_vector;
    }

    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 current_knight_mask, std::vector<int> &linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        current_knight_mask ^= from_mask;
        current_knight_mask ^= to_mask;
        if (to_mask & white_pieces_mask)
        {
            MaskToCapture(to_mask, true);
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }

        return current_knight_mask;
    }
};


===== BlackPawn.h =====
#pragma once
#include "Pawn.h"

class BlackPawn : public Pawn, public Black
{
private:
    std::array<U64, 64> black_pawn_pre_attacks;
    std::array<U64, 64> black_pawn_pre_moves;
    std::array<std::vector<int>, 64> coordinates_black_pawn_pre_moves;
    std::vector<std::pair<int, int>> black_pawn_moves;

public:
    void CalculateBlackPawnsPreMoves()
    {
        for (int i = 8; i < 56; ++i)
        {
            int move = i - 8;
            black_pawn_pre_moves[i] = 1ULL << move;
            coordinates_black_pawn_pre_moves[i].push_back(move);

            if (i / 8 == 6)
            {
                int double_step_move = i - 16;
                int one_step_move = i - 8;

                U64 one_step_mask = 1ULL << one_step_move;
                U64 double_step_mask = 1ULL << double_step_move;

                if (!(one_step_mask & all_pieces_mask) && !(double_step_mask & all_pieces_mask))
                {
                    black_pawn_pre_moves[i] |= double_step_mask;
                    coordinates_black_pawn_pre_moves[i].push_back(double_step_move);
                }
            }
        }
    }

    void CalculateBlackPawnsPreAttacks()
    {
        for (int i = 8; i < 56; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;

            if (from_file != 0)
            {
                int attack_left = i - 9;
                if (attack_left >= 0 && attack_left < 64)
                {
                    black_pawn_pre_attacks[i] |= 1ULL << attack_left;
                    pre_attacks_coordinates[i].push_back(attack_left);
                }
            }

            if (from_file != 7)
            {
                int attack_right = i - 7;
                if (attack_right >= 0 && attack_right < 64)
                {
                    black_pawn_pre_attacks[i] |= 1ULL << attack_right;
                    pre_attacks_coordinates[i].push_back(attack_right);
                }
            }
        }
    }

    std::vector<std::pair<int, int>> CalculateBlackPawnsMoves()
    {
        black_pawn_moves.clear();

        for (int from_square : linear_coordinates)
        {
            for (int to_square : coordinates_black_pawn_pre_moves[from_square])
            {
                U64 target_mask = 1ULL << to_square;
                if (!(target_mask & all_pieces_mask))
                {
                    black_pawn_moves.emplace_back(from_square, to_square);
                }
            }

            if (from_square / 8 == 6)
            {
                int one_step_square = from_square - 8;
                int double_step_square = from_square - 16;

                U64 one_step_mask = 1ULL << one_step_square;
                U64 double_step_mask = 1ULL << double_step_square;

                if (!(one_step_mask & all_pieces_mask) && !(double_step_mask & all_pieces_mask))
                {
                    black_pawn_moves.emplace_back(from_square, double_step_square);
                }
            }

            for (int attack_square : pre_attacks_coordinates[from_square])
            {
                U64 attack_mask = 1ULL << attack_square;
                if (attack_mask & white_pieces_mask)
                {
                    black_pawn_moves.emplace_back(from_square, attack_square);
                }
            }
        }
        return black_pawn_moves;
    }

    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 current_pawn_mask, std::vector<int> &linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        current_pawn_mask ^= from_mask;
        current_pawn_mask ^= to_mask;

        if (to_mask & white_pieces_mask)
        {
            MaskToCapture(to_mask, false);
        }

        if (move_to_execute.second <= 7 && move_to_execute.second >= 0)
        {
            std::vector<std::pair<int, char>> promotion_choices;
            promotion_choices.push_back({move_to_execute.second, 'Q'});
            promotion_choices.push_back({move_to_execute.second, 'R'});
            promotion_choices.push_back({move_to_execute.second, 'N'});
            promotion_choices.push_back({move_to_execute.second, 'B'});

            for (auto &promotion : promotion_choices)
            {
                char promotion_type = promotion.second;
                U64 promotion_mask = 1ULL << promotion.first;

                switch (promotion_type)
                {
                case 'Q':
                    BlackQueen::black_queens_mask |= promotion_mask;
                    break;
                case 'R':
                    BlackRook::black_rooks_mask |= promotion_mask;
                    break;
                case 'N':
                    BlackKnight::black_knights_mask |= promotion_mask;
                    break;
                case 'B':
                    BlackBishop::black_bishops_mask |= promotion_mask;
                    break;
                }
            }
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
                break;
            }
        }

        return current_pawn_mask;
    }
};


===== BlackQueen.h =====
#pragma once
#include "Queen.h"
class BlackQueen : public Queen
{
public:
    void CalculateBlackQueensPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;
            for (auto each : possible_moves)
            {
                int to_square = i + each;
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;

                    if (each == -8 || each == 8)
                    {
                        while (std::abs(from_file - to_file) == 0 && to_square >= 0 && to_square < 64)
                        {
                            pre_attacks_coordinates.at(i).push_back(to_square);
                            to_square += each;
                        }
                    }
                    else if (each == -1 || each == 1)
                    {
                        while (std::abs(from_rank - to_rank) == 0 && to_square >= 0 && to_square < 64)
                        {
                            pre_attacks_coordinates.at(i).push_back(to_square);
                            to_square += each;
                        }
                    }
                    else
                    {
                        while (std::abs(from_rank - to_rank) == 1 && std::abs(from_file - to_file) == 1 && to_square >= 0 && to_square < 64)
                        {
                            pre_attacks_coordinates.at(i).push_back(to_square);
                            to_square += each;
                        }
                    }
                }
            }
        }
    }

    std::vector<std::pair<int, int>> CalculateBlackQueensMoves()
    {
        moves_vector.clear();

        for (int from_square : linear_coordinates)
        {
            const auto &attacks = pre_attacks_coordinates.at(from_square);
            for (size_t i = 0; i < attacks.size(); ++i)
            {
                int to_square = attacks[i];
                U64 target_mask = 1ULL << to_square;

                if (!(target_mask & all_pieces_mask))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                }
                else if (target_mask & white_pieces_mask)
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));

                    int current_direction = to_square - from_square;
                    if (current_direction > 1 || current_direction < -1)
                    {
                        current_direction = current_direction > 0 ? 8 : -8;
                    }

                    while (i + 1 < attacks.size() &&
                           (attacks[i + 1] - from_square) / abs(current_direction) == 1)
                    {
                        ++i;
                    }
                }
                else
                {
                    int current_direction = to_square - from_square;
                    if (current_direction > 1 || current_direction < -1)
                    {
                        current_direction = current_direction > 0 ? 8 : -8;
                    }

                    while (i + 1 < attacks.size() &&
                           (attacks[i + 1] - from_square) / abs(current_direction) == 1)
                    {
                        ++i;
                    }
                }
            }
        }
        return moves_vector;
    }

    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 from_square_queen_mask, std::vector<int> &linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        from_square_queen_mask ^= from_mask;
        from_square_queen_mask ^= to_mask;
        if (to_mask & white_pieces_mask)
        {
            MaskToCapture(to_mask, true);
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }

        return from_square_queen_mask;
    }
};


===== BlackRook.h =====
#pragma once
#include "Rook.h"

class BlackRook : public Rook
{
public:
    void CalculateBlackRooksPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;
            for (auto each : possible_moves)
            {
                int to_square = i + each;
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;

                    if (each == -8 || each == 8)
                    {
                        while (std::abs(from_file - to_file) == 0 && to_square >= 0 && to_square < 64)
                        {
                            pre_attacks_coordinates.at(i).push_back(to_square);
                            to_square += each;
                        }
                    }
                    else
                    {
                        while (std::abs(from_rank - to_rank) == 0 && to_square >= 0 && to_square < 64)
                        {
                            pre_attacks_coordinates.at(i).push_back(to_square);
                            to_square += each;
                        }
                    }
                }
            }
        }
    }

    std::vector<std::pair<int, int>> CalculateBlackRooksMoves()
    {
        moves_vector.clear();

        for (int from_square : linear_coordinates)
        {
            const auto &attacks = pre_attacks_coordinates.at(from_square);
            for (size_t i = 0; i < attacks.size(); ++i)
            {
                int to_square = attacks[i];
                U64 target_mask = 1ULL << to_square;

                if (!(target_mask & all_pieces_mask))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                }
                else if (target_mask & white_pieces_mask)
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));

                    int current_direction = to_square - from_square;

                    if (current_direction > 1 || current_direction < -1)
                    {
                        current_direction = current_direction > 0 ? 8 : -8;
                    }

                    while (i + 1 < attacks.size() &&
                           (attacks[i + 1] - from_square) / abs(current_direction) == 1)
                    {
                        ++i;
                    }
                }
                else
                {
                    int current_direction = to_square - from_square;
                    if (current_direction > 1 || current_direction < -1)
                    {
                        current_direction = current_direction > 0 ? 8 : -8;
                    }

                    while (i + 1 < attacks.size() &&
                           (attacks[i + 1] - from_square) / abs(current_direction) == 1)
                    {
                        ++i;
                    }
                }
            }
        }
        return moves_vector;
    }

    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 from_square_rook_mask, std::vector<int> &linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        from_square_rook_mask ^= from_mask;
        from_square_rook_mask ^= to_mask;
        if (to_mask & white_pieces_mask)
        {
            MaskToCapture(to_mask, true);
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }

        return from_square_rook_mask;
    }
};


===== Display.h =====
#pragma once
#include "Piece.h"

void print_bitboard()
{
    for (int i = 7 ; i < 0; ++i)
    {
        for (int j = 0 ; j < 7; ++j)
        {
            std::cout << ((Piece::bitboard >> (i * 8 + j)) & 1) << " "; 
        }
        std::cout << std::endl;
    }
}


===== Engine.h =====
#pragma once
#include "Piece.h"
#include "WhitePawn.h"
#include "WhiteKnight.h"
#include "WhiteBishop.h"
#include "WhiteRook.h"
#include "WhiteQueen.h"
#include "WhiteKing.h"
#include "BlackPawn.h"
#include "BlackKnight.h"
#include "BlackBishop.h"
#include "BlackRook.h"
#include "BlackQueen.h"
#include "BlackKing.h"

class Engine
{
    int isMove = 1;
    const std::array<float, 64> knight_table = {
        2.5, 2.7, 2.9, 2.9, 2.9, 2.9, 2.7, 2.5,
        2.7, 2.9, 3.0, 3.0, 3.0, 3.0, 2.9, 2.7,
        2.9, 3.0, 3.2, 3.3, 3.3, 3.2, 3.0, 2.9,
        2.9, 3.1, 3.3, 3.4, 3.4, 3.3, 3.1, 2.9,
        2.9, 3.0, 3.3, 3.4, 3.4, 3.3, 3.0, 2.9,
        2.9, 3.1, 3.2, 3.3, 3.3, 3.2, 3.1, 2.9,
        2.7, 2.9, 3.0, 3.1, 3.1, 3.0, 2.9, 2.7,
        2.5, 2.7, 2.9, 2.9, 2.9, 2.9, 2.7, 2.5
    };
    const std::array<float, 64> bishop_table = {
        2.9, 3.0, 3.1, 3.1, 3.1, 3.1, 3.0, 2.9,
        3.0, 3.2, 3.3, 3.3, 3.3, 3.3, 3.2, 3.0,
        3.1, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.1,
        3.1, 3.4, 3.5, 3.6, 3.6, 3.5, 3.4, 3.1,
        3.1, 3.3, 3.5, 3.6, 3.6, 3.5, 3.3, 3.1,
        3.1, 3.4, 3.4, 3.5, 3.5, 3.4, 3.4, 3.1,
        3.0, 3.2, 3.3, 3.3, 3.3, 3.3, 3.2, 3.0,
        2.9, 3.0, 3.1, 3.1, 3.1, 3.1, 3.0, 2.9
    };
    const std::array<float, 64> rook_table = {
        3.1, 3.1, 3.1, 3.2, 3.2, 3.1, 3.1, 3.1,
        3.1, 3.2, 3.2, 3.3, 3.3, 3.2, 3.2, 3.1,
        3.1, 3.2, 3.3, 3.4, 3.4, 3.3, 3.2, 3.1,
        3.2, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.2,
        3.2, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.2,
        3.1, 3.2, 3.3, 3.4, 3.4, 3.3, 3.2, 3.1,
        3.1, 3.2, 3.2, 3.3, 3.3, 3.2, 3.2, 3.1,
        3.1, 3.1, 3.1, 3.2, 3.2, 3.1, 3.1, 3.1
    };
    const std::array<float, 64> queen_table = {
        3.0, 3.0, 3.0, 3.1, 3.1, 3.0, 3.0, 3.0,
        3.0, 3.2, 3.2, 3.3, 3.3, 3.2, 3.2, 3.0,
        3.0, 3.2, 3.3, 3.4, 3.4, 3.3, 3.2, 3.0,
        3.1, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.1,
        3.1, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.1,
        3.0, 3.2, 3.3, 3.4, 3.4, 3.3, 3.2, 3.0,
        3.0, 3.2, 3.2, 3.3, 3.3, 3.2, 3.2, 3.0,
        3.0, 3.0, 3.0, 3.1, 3.1, 3.0, 3.0, 3.0
    };
    const std::array<float, 64> pawn_table_white = {
        3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0,
        3.1, 3.1, 3.1, 3.2, 3.2, 3.1, 3.1, 3.1,
        3.2, 3.2, 3.3, 3.4, 3.4, 3.3, 3.2, 3.2,
        3.3, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.3,
        3.4, 3.4, 3.5, 3.6, 3.6, 3.5, 3.4, 3.4,
        3.5, 3.5, 3.6, 3.7, 3.7, 3.6, 3.5, 3.5,
        3.6, 3.6, 3.7, 3.8, 3.8, 3.7, 3.6, 3.6,
        3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0
    };
    const std::array<float, 64> pawn_table_black = {
        3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0,
        3.6, 3.6, 3.7, 3.8, 3.8, 3.7, 3.6, 3.6,
        3.5, 3.5, 3.6, 3.7, 3.7, 3.6, 3.5, 3.5,
        3.4, 3.4, 3.5, 3.6, 3.6, 3.5, 3.4, 3.4,
        3.3, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.3,
        3.2, 3.2, 3.3, 3.4, 3.4, 3.3, 3.2, 3.2,
        3.1, 3.1, 3.1, 3.2, 3.2, 3.1, 3.1, 3.1,
        3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0
    };
    const std::array<float, 64> king_table_midgame_white = {
        2.0, 2.1, 2.1, 2.0, 2.0, 2.1, 2.1, 2.0,
        2.0, 2.2, 2.2, 2.1, 2.1, 2.2, 2.2, 2.0,
        2.0, 2.2, 2.3, 2.3, 2.3, 2.3, 2.2, 2.0,
        2.0, 2.3, 2.4, 2.4, 2.4, 2.4, 2.3, 2.0,
        2.0, 2.3, 2.4, 2.4, 2.4, 2.4, 2.3, 2.0,
        2.0, 2.2, 2.3, 2.3, 2.3, 2.3, 2.2, 2.0,
        2.0, 2.2, 2.2, 2.1, 2.1, 2.2, 2.2, 2.0,
        2.0, 2.1, 2.1, 2.0, 2.0, 2.1, 2.1, 2.0
    };
    
    const std::array<float, 64> king_table_midgame_black = {
        2.0, 2.1, 2.1, 2.0, 2.0, 2.1, 2.1, 2.0,
        2.0, 2.2, 2.2, 2.1, 2.1, 2.2, 2.2, 2.0,
        2.0, 2.2, 2.3, 2.3, 2.3, 2.3, 2.2, 2.0,
        2.0, 2.3, 2.4, 2.4, 2.4, 2.4, 2.3, 2.0,
        2.0, 2.3, 2.4, 2.4, 2.4, 2.4, 2.3, 2.0,
        2.0, 2.2, 2.3, 2.3, 2.3, 2.3, 2.2, 2.0,
        2.0, 2.2, 2.2, 2.1, 2.1, 2.2, 2.2, 2.0,
        2.0, 2.1, 2.1, 2.0, 2.0, 2.1, 2.1, 2.0
    };
    const std::array<float, 64> king_table_endgame_white = {
        3.0, 3.1, 3.2, 3.3, 3.3, 3.2, 3.1, 3.0,
        3.1, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.1,
        3.2, 3.4, 3.6, 3.7, 3.7, 3.6, 3.4, 3.2,
        3.3, 3.5, 3.7, 3.8, 3.8, 3.7, 3.5, 3.3,
        3.3, 3.5, 3.7, 3.8, 3.8, 3.7, 3.5, 3.3,
        3.2, 3.4, 3.6, 3.7, 3.7, 3.6, 3.4, 3.2,
        3.1, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.1,
        3.0, 3.1, 3.2, 3.3, 3.3, 3.2, 3.1, 3.0
    };
    
    const std::array<float, 64> king_table_endgame_black = {
        3.0, 3.1, 3.2, 3.3, 3.3, 3.2, 3.1, 3.0,
        3.1, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.1,
        3.2, 3.4, 3.6, 3.7, 3.7, 3.6, 3.4, 3.2,
        3.3, 3.5, 3.7, 3.8, 3.8, 3.7, 3.5, 3.3,
        3.3, 3.5, 3.7, 3.8, 3.8, 3.7, 3.5, 3.3,
        3.2, 3.4, 3.6, 3.7, 3.7, 3.6, 3.4, 3.2,
        3.1, 3.3, 3.4, 3.5, 3.5, 3.4, 3.3, 3.1,
        3.0, 3.1, 3.2, 3.3, 3.3, 3.2, 3.1, 3.0
    };
    

public:
    float Evaluate()
    {
        float white_sum = 0;
        float black_sum = 0;
        
        for(int i = 0; i < WhitePawn::linear_coordinates.size(); ++i)
        {
            white_sum += pawn_table_white.at(WhitePawn::linear_coordinates.at(i));
        } 
        for(int i = 0; i < WhiteKnight::linear_coordinates.size(); ++i)
        {
            white_sum += knight_table.at(WhiteKnight::linear_coordinates.at(i));
        }
        for(int i = 0; i < WhiteBishop::linear_coordinates.size(); ++i)
        {
            white_sum += bishop_table.at(WhiteBishop::linear_coordinates.at(i));
        }
        for(int i = 0; i < WhiteRook::linear_coordinates.size(); ++i)
        {
            white_sum += rook_table.at(WhiteRook::linear_coordinates.at(i));
        }
        for(int i = 0; i < WhiteQueen::linear_coordinates.size(); ++i)
        {
            white_sum += queen_table.at(WhiteQueen::linear_coordinates.at(i));
        }
        for(int i = 0; i < WhiteKing::linear_coordinates.size(); ++i)
        {
            white_sum += king_table_midgame_white.at(WhiteKing::linear_coordinates.at(i));
        }
        for(int i = 0; i < BlackPawn::linear_coordinates.size(); ++i)
        {
            black_sum += pawn_table_black.at(BlackPawn::linear_coordinates.at(i));
        }
        for(int i = 0; i < BlackKnight::linear_coordinates.size(); ++i)
        {
            black_sum += knight_table.at(BlackKnight::linear_coordinates.at(i));
        }
        for(int i = 0; i < BlackBishop::linear_coordinates.size(); ++i)
        {
            black_sum += bishop_table.at(BlackBishop::linear_coordinates.at(i));
        }
        for(int i = 0; i < BlackRook::linear_coordinates.size(); ++i)
        {
            black_sum += rook_table.at(BlackRook::linear_coordinates.at(i));
        }
        for(int i = 0; i < BlackQueen::linear_coordinates.size(); ++i)
        {
            black_sum += queen_table.at(BlackQueen::linear_coordinates.at(i));
        }
        for(int i = 0; i < BlackKing::linear_coordinates.size(); ++i)
        {
            black_sum += king_table_midgame_black.at(BlackKing::linear_coordinates.at(i));
        }
        return white_sum - black_sum;
    }

    void ExecuteMove(std::pair<int, int> move_to_execute, U64 from_mask, U64 to_mask, std::vector<int>& linear_coordinates)
    {
        from_mask ^= 1ULL << move_to_execute.first;
        from_mask ^= 1ULL << move_to_execute.second;
        if (to_mask & Piece::whole_bitboard)
        {
            Piece::MaskToCapture(to_mask, false);
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }
        isMove ^= 1;
    }
};  


===== King.h =====
#pragma once
#include "Piece.h"

class King : virtual public Piece
{
protected:
    std::array<int, 8> possible_moves = {-9, -8, -7, -1, 1, 7, 8, 9};
};


===== Knight.h =====
#pragma once
#include "Piece.h"

class Knight : virtual public Piece
{
protected:    
    std::array<int, 8> possible_moves = {6, 15, 17, 10, -6, -15, -17, -10};
};


===== Pawn.h =====
#pragma once
#include "Piece.h"

class Pawn : virtual public Piece
{
protected:

};


===== Piece.h =====
#pragma once
#include <array>
#include <utility>
#include <vector>
#include <iostream>
#include <utility>

using U64 = unsigned long long;

class Piece
{
public:
    static void MaskToCapture(U64 to_mask, bool isWhite);
    std::array<std::vector<int>, 64> pre_attacks_coordinates;
    static U64 bitboard;
    std::vector<int> linear_coordinates;
    std::vector<std::pair<int, int>> moves_vector;

    static U64 white_bitboard;
    static U64 black_bitboard;
    static U64 whole_bitboard;
    
};


===== Queen.h =====
#pragma once
#include "Piece.h"

class Queen : virtual public Piece
{
protected:
    std::array<int, 8> possible_moves = {-9, -8, -7, -1, 1, 7, 8, 9};
};


===== Rook.h =====
#pragma once
#include "Piece.h"

class Rook : virtual public Piece
{
protected:
    std::array<int, 4> possible_moves = {-8, -1, 1, 8};
};


===== White.h =====
#pragma once
#include "Piece.h"
#include "Black.h"

class White: virtual public Piece
{
private:
    static std::array<U64, 6> bitboards;
    
protected:
    const bool isWhite = true;

public:
    static U64 squares_controlled;
};


===== WhiteBishop.h =====
#pragma once
#include "Bishop.h"
#include "White.h"

class WhiteBishop : public Bishop, public White
{
public:
    void CalculateWhiteBishopsPreAttacks()
    {        
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;
            for (auto each : possible_moves)
            {
                int to_square = i + each;
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;

                    while(std::abs(from_rank - to_rank) == 1 && std::abs(from_file - to_file) == 1 && to_square >= 0 && to_square < 64)
                    {
                        pre_attacks_coordinates.at(i).push_back(to_square);
                        to_square += each;
                    }
                }
            }    
        }
    }
    std::vector<std::pair<int, int>> CalculateWhiteBishopsMoves()
    {
        moves_vector.clear();
       
        for (int from_square : linear_coordinates)
        {
            const auto& attacks = pre_attacks_coordinates.at(from_square);
            for (size_t i = 0; i < attacks.size(); ++i)
            {
                int to_square = attacks[i];
                U64 target_mask = 1ULL << to_square;
                
                if(!(target_mask & all_pieces_mask))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;
                }
                else if (target_mask & black_pieces_mask)
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;

                    int current_direction = to_square - from_square;
                    
                    while (i + 1 < attacks.size() && 
                            (attacks[i+1] - from_square) / abs(attacks[i+1] - from_square) == 
                            current_direction / abs(current_direction))
                    {
                        ++i;
                    }
                }
                else
                {
                    int current_direction = to_square - from_square;
                    
                    while (i + 1 < attacks.size() && 
                            (attacks[i+1] - from_square) / abs(attacks[i+1] - from_square) == 
                            current_direction / abs(current_direction))
                    {
                        ++i;
                    }
                }
            }
        }
        return moves_vector;
    }
    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 from_square_bishop_mask, std::vector<int>& linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        from_square_bishop_mask ^= from_mask;
        from_square_bishop_mask ^= to_mask;
        if (to_mask & black_pieces_mask)
        {
            MaskToCapture(to_mask, false);
        }

        for(int i = 0; i < linear_coordinates.size(); ++i)
        {
            if(linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }
        return from_square_bishop_mask;
    }
};







===== WhiteKing.h =====
#pragma once
#include "King.h"
#include "White.h"

class WhiteKing : public King, public White
{
public:
    void CalculateWhiteKingPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;

            for (int j = 0; j < 8; ++j)
            {
                int to_square = i + possible_moves[j];
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;
                    int diff_rank = abs(from_rank - to_rank);
                    int diff_file = abs(from_file - to_file);
                    if ((diff_file == 1 && diff_rank == 1) || (diff_file == 1 && diff_rank == 0) || (diff_file == 0 && diff_rank == 1))
                    {
                        pre_attacks_coordinates[i].push_back(to_square);
                    }
                }
            }
        }
    }
    std::vector<std::pair<int, int>> CalculateWhiteKingMoves()
    {
        moves_vector.clear();
        
        for (int from_square : linear_coordinates)
        {
            for (int to_square : pre_attacks_coordinates[from_square])
            {
                U64 target_mask = 1ULL << to_square;
                if(!(target_mask & white_pieces_mask) && !(target_mask & Black::squares_controlled))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;
                }
            }
        }
        return moves_vector;
    }
    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 from_square_king_mask, std::vector<int>& linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        from_square_king_mask ^= from_mask;
        from_square_king_mask ^= to_mask;
        if (to_mask & black_pieces_mask)
        {
            MaskToCapture(to_mask, false);
        }

        for(int i = 0; i < linear_coordinates.size(); ++i)
        {
            if(linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }
        return from_square_king_mask;
    }
};







===== WhiteKnight.h =====
#pragma once
#include "Knight.h"
#include "White.h"

class WhiteKnight : public Knight, public White
{
public:
    void CalculateWhiteKnightsPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;

            for (int j = 0; j < 8; ++j)
            {
                int to_square = i + possible_moves[j];
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;
                    int diff_rank = abs(from_rank - to_rank);
                    int diff_file = abs(from_file - to_file);
                    if (diff_file + diff_rank == 3 && diff_file > 0 && diff_rank > 0)
                    {
                        pre_attacks_coordinates[i].push_back(to_square);
                    }
                }
            }
        }
    }
    std::vector<std::pair<int, int>> CalculateWhiteKnightsMoves()
    {
        moves_vector.clear();
        
        for (int from_square : linear_coordinates)
        {
            for (int to_square : pre_attacks_coordinates[from_square])
            {
                U64 target_mask = 1ULL << to_square;
                if(!(target_mask & white_pieces_mask))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;
                }
            }
        }
        return moves_vector;
    }
    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 current_knight_mask, std::vector<int>& linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        current_knight_mask ^= from_mask;
        current_knight_mask ^= to_mask;
        if (to_mask & black_pieces_mask)
        {
            MaskToCapture(to_mask, false);
        }

        for(int i = 0; i < linear_coordinates.size(); ++i)
        {
            if(linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }
        return current_knight_mask;
    }
};







===== WhitePawn.h =====
#pragma once
#include "Pawn.h"
#include "White.h"

class WhitePawn : public Pawn, public White
{
private:
    // std::vector<int> linear_coordinates{8, 9, 10, 11, 12, 13, 14, 15};
    std::array<U64, 64> white_pawn_pre_attacks;
    std::array<U64, 64> white_pawn_pre_moves;
    std::array<std::vector<int>, 64> coordinates_white_pawn_pre_moves;
    std::vector<std::pair<int, int>> white_pawn_moves;

public:

    void CalculateWhitePawnsPreMoves()
    {
        for (int i = 8; i < 56; ++i)
        {
            int move = i + 8;
            white_pawn_pre_moves[i] = 1ULL << move;
            coordinates_white_pawn_pre_moves[i].push_back(move);

            if (i / 8 == 1)
            {
                int double_step_move = i + 16;
                int one_step_move = i + 8;

                if (!(white_pawn_pre_moves[i] & all_pieces_mask) && !(white_pawn_pre_moves[one_step_move] & all_pieces_mask))
                {
                    white_pawn_pre_moves[i] |= 1ULL << double_step_move;
                    coordinates_white_pawn_pre_moves[i].push_back(double_step_move);
                }
            }
        }
    }

    void CalculateWhitePawnsPreAttacks()
    {
        for (int i = 8; i < 56; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;

            if (from_file != 0)
            {
                int attack_left = i + 7;
                if (attack_left >= 0 && attack_left < 64)
                {
                    white_pawn_pre_attacks[i] |= 1ULL << attack_left;
                    pre_attacks_coordinates[i].push_back(attack_left);
                }
            }

            if (from_file != 7)
            {
                int attack_right = i + 9;
                if (attack_right >= 0 && attack_right < 64)
                {
                    white_pawn_pre_attacks[i] |= 1ULL << attack_right;
                    pre_attacks_coordinates[i].push_back(attack_right);
                }
            }
        }
    }

    std::vector<std::pair<int, int>> CalculateWhitePawnsMoves()
    {
        white_pawn_moves.clear();

        for (int from_square : linear_coordinates)
        {
            for (int to_square : coordinates_white_pawn_pre_moves[from_square])
            {
                U64 target_mask = 1ULL << to_square;
                if (!(target_mask & all_pieces_mask))
                {
                    white_pawn_moves.emplace_back(from_square, to_square);
                }
            }

            if (from_square / 8 == 1)
            {
                int one_step_square = from_square + 8;
                int double_step_square = from_square + 16;

                U64 one_step_mask = 1ULL << one_step_square;
                U64 double_step_mask = 1ULL << double_step_square;

                if (!(one_step_mask & all_pieces_mask) && !(double_step_mask & all_pieces_mask))
                {
                    white_pawn_moves.emplace_back(from_square, double_step_square);
                }
            }

            for (int attack_square : pre_attacks_coordinates[from_square])
            {
                U64 attack_mask = 1ULL << attack_square;
                if (attack_mask & black_pieces_mask)
                {
                    white_pawn_moves.emplace_back(from_square, attack_square);
                    squares_controlled |= attack_square;
                }
            }
        }
        return white_pawn_moves;
    }

    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 current_pawn_mask, std::vector<int> &linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        current_pawn_mask ^= from_mask;
        current_pawn_mask ^= to_mask;

        if (to_mask & black_pieces_mask)
        {
            MaskToCapture(to_mask, true);
        }

        if (move_to_execute.second >= 56 && move_to_execute.second <= 63)
        {
            std::vector<std::pair<int, char>> promotion_choices;
            promotion_choices.push_back({move_to_execute.second, 'Q'});
            promotion_choices.push_back({move_to_execute.second, 'R'});
            promotion_choices.push_back({move_to_execute.second, 'N'});
            promotion_choices.push_back({move_to_execute.second, 'B'});

            for (auto &promotion : promotion_choices)
            {
                char promotion_type = promotion.second;
                U64 promotion_mask = 1ULL << promotion.first;

                switch (promotion_type)
                {
                case 'Q':
                    WhiteQueen::white_queens_mask |= promotion_mask;
                    break;
                case 'R':
                    WhiteRook::white_rooks_mask |= promotion_mask;
                    break;
                case 'N':
                    WhiteKnight::white_knights_mask |= promotion_mask;
                    break;
                case 'B':
                    WhiteBishop::white_bishops_mask |= promotion_mask;
                    break;
                }
            }
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
                break;
            }
        }

        return current_pawn_mask;
    }
};






===== WhiteQueen.h =====
#pragma once
#include "Queen.h"
#include "White.h"

class WhiteQueen : public Queen, public White
{
public:
    void CalculateWhiteQueensPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;
            for (auto each : possible_moves)
            {
                int to_square = i + each;
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;

                    if(each == -8 || each == 8){
                        while(std::abs(from_file - to_file) == 0 && to_square >= 0 && to_square < 64)
                        {
                            pre_attacks_coordinates.at(i).push_back(to_square);
                            to_square += each;
                        }
                    }
                    else if(each == -1 || each == 1){
                        while(std::abs(from_rank - to_rank) == 0 && to_square >= 0 && to_square < 64)
                        {
                            pre_attacks_coordinates.at(i).push_back(to_square);
                            to_square += each;
                        }
                    }
                    else
                    {
                        while(std::abs(from_rank - to_rank) == 1 && std::abs(from_file - to_file) == 1 && to_square >= 0 && to_square < 64)
                        {
                            pre_attacks_coordinates.at(i).push_back(to_square);
                            to_square += each;
                        }
                    }
                }
            }
        }
    }

    std::vector<std::pair<int, int>> CalculateWhiteQueensMoves()
    {
        moves_vector.clear();

        for (int from_square : linear_coordinates)
        {
            const auto& attacks = pre_attacks_coordinates.at(from_square);
            for (size_t i = 0; i < attacks.size(); ++i)
            {
                int to_square = attacks[i];
                U64 target_mask = 1ULL << to_square;

                if (!(target_mask & all_pieces_mask))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;
                }
                else if (target_mask & black_pieces_mask)
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;

                    int current_direction = to_square - from_square;
                   if(current_direction > 1 || current_direction < -1)
                    {
                        current_direction = current_direction > 0 ? 8 : -8;
                    }

                    while (i + 1 < attacks.size() &&
                           (attacks[i + 1] - from_square) / abs(current_direction) == 1)
                    {
                        ++i;
                    }
                }
                else
                {
                   int current_direction = to_square - from_square;
                    if(current_direction > 1 || current_direction < -1)
                    {
                        current_direction = current_direction > 0 ? 8 : -8;
                    }

                    while (i + 1 < attacks.size() &&
                            (attacks[i + 1] - from_square) / abs(current_direction) == 1)
                    {
                        ++i;
                    }
                }
            }
        }
        return moves_vector;
    }

    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 from_square_queen_mask, std::vector<int>& linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        from_square_queen_mask ^= from_mask;
        from_square_queen_mask ^= to_mask;
        if (to_mask & black_pieces_mask)
        {
            MaskToCapture(to_mask, false);
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }

        return from_square_queen_mask;
    }
};







===== WhiteRook.h =====
#pragma once
#include "Rook.h"
#include "White.h"

class WhiteRook : public Rook, public White
{
public:
    void CalculateWhiteRooksPreAttacks()
    {
        for (int i = 0; i < 64; ++i)
        {
            int from_rank = i / 8;
            int from_file = i % 8;
            for (auto each : possible_moves)
            {
                int to_square = i + each;
                if (to_square >= 0 && to_square < 64)
                {
                    int to_rank = to_square / 8;
                    int to_file = to_square % 8;
                    
                    while(((std::abs(from_rank - to_rank) == 1 && std::abs(from_file - to_file) == 0) || (std::abs(from_rank - to_rank) == 0 && std::abs(from_file - to_file) == 1)) && to_square >= 0 && to_square < 64)
                    {
                        pre_attacks_coordinates.at(i).push_back(to_square);
                        to_square += each;
                    }
                }
            }
        }
    }

    std::vector<std::pair<int, int>> CalculateWhiteRooksMoves()
    {
        moves_vector.clear();

        for (int from_square : linear_coordinates)
        {
            const auto& attacks = pre_attacks_coordinates.at(from_square);
            for (size_t i = 0; i < attacks.size(); ++i)
            {
                int to_square = attacks[i];
                U64 target_mask = 1ULL << to_square;

                if (!(target_mask & whole_bitboard))
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;
                }
                else if (target_mask & black_bitboard)
                {
                    moves_vector.push_back(std::make_pair(from_square, to_square));
                    squares_controlled |= target_mask;

                    int current_direction = to_square - from_square;

                    if(current_direction > 1 || current_direction < -1)
                    {
                        current_direction = current_direction > 0 ? 8 : -8;
                    }

                    while (i + 1 < attacks.size() &&
                            (attacks[i + 1] - from_square) / abs(current_direction) == 1)
                    {
                        ++i;
                    }
                }
                else
                {
                    int current_direction = to_square - from_square;
                    if(current_direction > 1 || current_direction < -1)
                    {
                        current_direction = current_direction > 0 ? 8 : -8;
                    }

                    while (i + 1 < attacks.size() &&
                            (attacks[i + 1] - from_square) / abs(current_direction) == 1)
                    {
                        ++i;
                    }
                }
            }
        }
        return moves_vector;
    }

    U64 ExecuteMove(std::pair<int, int> move_to_execute, U64 from_square_rook_mask, std::vector<int>& linear_coordinates)
    {
        U64 from_mask = 1ULL << move_to_execute.first;
        U64 to_mask = 1ULL << move_to_execute.second;
        from_square_rook_mask ^= from_mask;
        from_square_rook_mask ^= to_mask;
        if (to_mask & black_bitboard)
        {
            MaskToCapture(to_mask, false);
        }

        for (int i = 0; i < linear_coordinates.size(); ++i)
        {
            if (linear_coordinates.at(i) == move_to_execute.first)
            {
                linear_coordinates.at(i) = move_to_execute.second;
            }
        }

        return from_square_rook_mask;
    }
};







